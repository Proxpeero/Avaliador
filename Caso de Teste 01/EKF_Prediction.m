function [x_k1_,P_k1_] = EKF_Prediction(u, dt, x_k, P_k, std_q, std_gyro)
% Função de transição de estado
f = @(x, u) [ ...
      x_k(1) + 0.5 * dt * (-x_k(2)*u(1) - x_k(3)*u(2) - x_k(4)*u(3)); ...
      x_k(2) + 0.5 * dt * ( x_k(1)*u(1) - x_k(4)*u(2) + x_k(3)*u(3)); ...
      x_k(3) + 0.5 * dt * ( x_k(4)*u(1) + x_k(1)*u(2) - x_k(2)*u(3)); ...
      x_k(4) + 0.5 * dt * (-x_k(3)*u(1) + x_k(2)*u(2) + x_k(1)*u(3)); ...
      x_k(5); ...
      x_k(6); ...
      x_k(7) ...
      ];

% Jacobiana da função de transição de estado
F = @(x, u) [ ...
                       1,  -0.5*dt*u(1),  -0.5*dt*u(2), -0.5*dt*u(3), 0, 0, 0; ...
             0.5*dt*u(1),             1,   0.5*dt*u(3), -0.5*dt*u(2), 0, 0, 0; ...
             0.5*dt*u(2),  -0.5*dt*u(3),             1,  0.5*dt*u(1), 0, 0, 0; ...
             0.5*dt*u(3),   0.5*dt*u(2),  -0.5*dt*u(1),            1, 0, 0, 0; ...
                       0,             0,             0,            0, 1, 0, 0; ...
                       0,             0,             0,            0, 0, 1, 0; ...
                       0,             0,             0,            0, 0, 0, 1 ...
        ];


Q = diag([std_q^2, std_q^2, std_q^2, std_q^2, std_gyro^2, std_gyro^2, std_gyro^2]); % Covariância do processo

% Predição
    x_k1_ = f(x_k, u);
    Fk = F(x_k, u);
    P_k1_ = Fk * P_k * Fk' + Q;
end
